# -*- coding: utf-8 -*-
"""JoseJuan_Anayara.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BO_bnXAKCtUOd1r5V7ONBpkmsjzMTSSo
"""

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np


import warnings

warnings.filterwarnings('ignore')

data = pd.read_csv("cardioBueno.csv",sep=",")

data.describe()

# NO EJECUTAR
# Iteración por columnas del DataFrame:
#Reemplazamos los valores atípicos de la altura por la media
for col in range(0,70000):
  if data["height"][col] <= 130 or data["height"][col] >= 220:
    data["height"][col] = data["height"].mean()

# NO EJECUTAR
#Reemplazamos los valores atípicos del peso por la media
for col in range(0,70000):
  if data["weight"][col] <= 50:
    data["weight"][col] = data["weight"].mean()

# NO EJECUTAR
#Reemplazamos los valores atípicos de la presión alta por la media
for col in range(0,70000):
  if data["ap_hi"][col] <= 80 or data["ap_hi"][col] >= 200:
    data["ap_hi"][col] = data["ap_hi"].mean()

# NO EJECUTAR
#Reemplazamos los valores atípicos de la presión baja por la media
for col in range(0,70000):
  if data["ap_lo"][col] <= 50 or data["ap_lo"][col] >= 170:
    data["ap_lo"][col] = data["ap_lo"].mean()

print("Tenemos",np.sum(np.sum(data.isna())),"valores Nulos")

print("El porcentaje de ataques personas con enfermedades cardiovasculares es: ",np.sum(data['cardio'])*100/len(data['cardio']),"%")

#Comprobamos el rango de edades

plt.figure(figsize=(10,5))
plt.hist(data['age'], color = 'aquamarine', edgecolor='blue', linewidth=0.5, bins=36)
plt.title('Rango y Número de edades')
plt.xlabel('Edades')
plt.ylabel('Nº de veces en los datos')
plt.show()

print("El valor minimo de edad es",data['age'].min())
print("El valor máximo de edad es",data['age'].max())

cardio = data[data["cardio"] == 1]
pM = (np.sum(data['gender']==1)/70000*100)
pH = (np.sum(data['gender']==2)/70000*100)
print("El porcentaje de mujeres es:",pM,"%")
print("de las cuales, un:",(np.sum(cardio['gender']==1)/(70000*pM/100)*100),"% han sufrido enfermedades cardiovasculares")
print("El porcentaje de hombres es:",pH,"%")
print("de las cuales, un:",(np.sum(cardio['gender']==2)/(70000*pH/100)*100),"% han sufrido enfermedades cardiovasculares")

mujeres = (np.sum(data['gender']==1)/68275)
hombres = (np.sum(data['gender']==2)/68275)
print("Mujeres: ",mujeres, " Hombres: ", hombres)

#Alturas

plt.hist(data['height'],color = 'aquamarine',edgecolor='blue', linewidth=0.5,bins=50,range=[120,200])#Dejamos fuera los outliers

plt.title('Rango alturas')
plt.xlabel('Alturas')
plt.ylabel('Nº de veces en los datos')
plt.show()

print("El valor minimo de altura es",data['height'].min())
print("El valor máximo de altura es",data['height'].max())

#Peso

plt.hist(data['weight'],color = 'aquamarine',edgecolor='blue', linewidth=0.5,bins=50,range=[30,150])#Dejamos fuera los outliers

plt.title('Rango pesos')
plt.xlabel('Pesos')
plt.ylabel('Nº de veces en los datos')
plt.show()

print("El valor minimo del peso es",data['weight'].min())
print("El valor máximo del peso es",data['weight'].max())

#Colesterol

print("El porcentaje de colesterol normal es:",np.round(len(data[data['cholesterol']==1])/70000*100,2),"%")
print("El porcentaje de colesterol sobre lo normal es:",np.round(len(data[data['cholesterol']==2])/70000*100,2),"%")
print("El porcentaje de colesterol muy por encima de lo normal es:",np.round(len(data[data['cholesterol']==3])/70000*100,2),"%")

#Glucosa

print("El porcentaje de glucosa normal es:",np.round(len(data[data['gluc']==1])/70000*100,2),"%")
print("El porcentaje de glucosa sobre lo normal es:",np.round(len(data[data['gluc']==2])/70000*100,2),"%")
print("El porcentaje de glucosa muy por encima de lo normal es:",np.round(len(data[data['gluc']==3])/70000*100,2),"%")

#Fumadores

print("El porcentaje de personas fumadoras es:",np.round(len(data[data['smoke']==1])/70000*100,2),"%")

#Consumo de Alcohol

print("El porcentaje de personas que consumen alcohol es:",np.round(len(data[data['alco']==1])/70000*100,2),"%")

#Personas activas

print("El porcentaje de personas activas es:",np.round(len(data[data['active']==1])/70000*100,2),"%")

#Relación Presión - colesterol
normalChol = data[data["cholesterol"] == 1]
hightChol = data[data["cholesterol"] == 3]

#colesterol normal que han tenido enfermedades
normalWith = normalChol[normalChol["cardio"] == 1]
normalNo = normalChol[normalChol["cardio"] == 0]
#colesterol altísimo
hightWith = hightChol[hightChol["cardio"] == 1]
hightNo = hightChol[hightChol["cardio"] == 0]

plt.scatter(normalWith["ap_lo"], normalWith["ap_hi"], color = "aquamarine", edgecolor = "black", label = "Normal con problemas")
plt.scatter(normalNo["ap_lo"], normalNo["ap_hi"], color = "red", edgecolor = "black", label = "Normal sin problemas")
plt.scatter(hightWith["ap_lo"], hightWith["ap_hi"], color = "green", edgecolor = "black", label = "Alto con problemas")
plt.scatter(hightNo["ap_lo"], hightNo["ap_hi"], color = "yellow", edgecolor = "black", label = "Alto sin problemas")

plt.title("Relación Presión - colesterol")
plt.xlabel("Presión diastólica (baja)")
plt.ylabel("Presión sistólica (alta)")
plt.legend()
plt.show()

#Relación Presión - colesterol
withChol = data[data["cholesterol"] == 1]
deathtChol = data[data["cholesterol"] == 3]

plt.scatter(withChol["ap_lo"], withChol["ap_hi"], color = "aquamarine", edgecolor = "black", label = "Colesterol normal")
plt.scatter(deathtChol["ap_lo"], deathtChol["ap_hi"], color = "red", edgecolor = "black", label = "Colesterol muy alto")
plt.title("Relación Presión - colesterol")
plt.xlabel("Presión diastólica (baja)")
plt.ylabel("Presión sistólica (alta)")
plt.legend()
plt.show()

#Relación Presión - actividad física 
active = data[data["active"] == 1]
noActive = data[data["active"] == 0]

plt.scatter(active["ap_lo"], active["ap_hi"], color = "aquamarine", edgecolor = "black", label = "Activos")
plt.scatter(noActive["ap_lo"], noActive["ap_hi"], color = "red", edgecolor = "black", label = "No activos")
plt.title("Relación Presión - actividad física")
plt.xlabel("Presión diastólica (baja)")
plt.ylabel("Presión sistólica (alta)")
plt.legend()
plt.show()

#Relación Presión - Fumadores
smoke = data[data["smoke"] == 1]
noSmoke = data[data["smoke"] == 0]

plt.scatter(noSmoke["ap_lo"], noSmoke["ap_hi"], color = "red", edgecolor = "black", label = "No fumador")
plt.scatter(smoke["ap_lo"], smoke["ap_hi"], color = "aquamarine", edgecolor = "black", label = "Fumador")
plt.title("Relación Presión - Fumador / No fumador")
plt.xlabel("Presión diastólica (baja)")
plt.ylabel("Presión sistólica (alta)")
plt.legend()
plt.show()

import seaborn as sb

correl = data.drop(['cardio'],axis=1)
Matriz = correl.corr()
plt.subplots(figsize=(13,10))
sb.heatmap(Matriz, cmap='RdBu_r', vmin=-1, vmax=1, square=True,linewidths=.2, annot = True, annot_kws={"size": 7})

Y = data['cardio']
X = data.drop(['cardio'],axis=1)

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()
scaled_X = scaler.fit_transform(X)
X = pd.DataFrame(scaled_X)

from sklearn.model_selection import train_test_split
from keras.layers.normalization import BatchNormalization

X_train, X_test, y_train, y_test = train_test_split(
        X, Y, test_size=0.3)

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import *
import keras


model = Sequential()
model.add(Dense(32, input_dim=11))
model.add(BatchNormalization())
model.add(Activation('relu'))

model.add(Dense(16))
model.add(BatchNormalization())
model.add(Activation('relu'))

model.add(Dense(8))
model.add(Activation('relu'))

model.add(Dense(1,activation='sigmoid'))

cb = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=5)

model.compile(loss='binary_crossentropy', optimizer='rmsprop', metrics=['accuracy'])

acc = model.fit(X_train, y_train, 
                epochs=15,
                callbacks=[cb],
                batch_size=32,
                validation_data=(X_test,y_test))

plt.xlabel("Epochs")
plt.ylabel("Error")
plt.plot(acc.history["loss"], label = "loss")
plt.plot(acc.history["val_loss"], label = "val_loss")
plt.legend()
plt.show()

model.evaluate(X_test,y_test, verbose=0)